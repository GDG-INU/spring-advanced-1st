# 3주차 학습내용

---

1. 트랜잭션 관리 (@Transactional)
    - 트랜잭션의 개념과 ACID 속성
    - @Transactional 어노테이션의 사용법과 속성
    - 트랜잭션 전파 설정 (propagation)
    - 트랜잭션 격리 수준 (isolation)
    - 낙관적 락과 비관적 락

---

# 트랜잭션의 개념과 ACID 속성

---

## 1. 트랜잭션(Transaction)이란?

<aside>
📄

여러 개의 작업을 하나로 묶은 실행 유닛

데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

</aside>

### ⚠️ 주의점

작업의 단위는 질의어 한문장이 아니다.

작업단위는 많은 질의어 명령문들을 사람이 정하는 기준에 따라 정하는 것을 의미한다.

### 예시

게시판 사용자가 게시글을 작성하고, 올리기 버튼을 누른다. 그 후 게시판에 돌아왔을 때, 게시판은 글이 포함된 업데이트된 게시판을 보게 되는데 이 과정을 데이터베이스 작업에선

사용자가 올리기 버튼을 누름 → Insert 문을 사용하여 데이터 이동 → 게시판을 구성할 데이터를 다시 Select → 최신정보 업데이트

여기서 **작업의 단위**는 insert문과 select문 둘다를 합친것이다. 이러한 작업 단위를 하나의 트랜잭션이라 한다.

---

## ACID란?

ACID는 트랜잭션의 특징을 4가지로 나타낸 것이다. 

![스크린샷 2024-11-12 19.08.33.png](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%2013c93df08ef28098b372ccc426f910b6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-12_19.08.33.png)

각각 Atomicity(원자성), Consistency(일관성), Isolation(독립성), Durability(지속성)

---

## ⚛️ Atomicity (원자성)

- 트랜잭션이 안정성 보장을 위해 가져야 할 성질 중의 하나
- 시스템에서 한 트랜잭션의 연산들이 모두 성공하거나, 반대로 전부 실패되는 성질
- 작업이 모두 반영되거나 모두 반영되지 않음으로서 결과를 예측할 수 있어야 한다.

### 예제

‘계좌이체’ 트랜잭션은 두 가지 단계가 존재한다

- A 계좌에서 출금
- B 계좌에 입금

→ 원자성을 준수하지 않을 경우 A 계좌에서는 출금이 이루어지고 B 계좌에 입금이 되지 않았다고 가정하면 A계좌에서 출금된 돈은 증발하는 일이 존재

→ 따라서, 위 같은 경우가 발생하면 A계좌에서 출금하는 작업을 포함하여 모든 작업이 실패로 돌아가야 원자성을 가지는 것이다.

성공 ✅ : 두 작업 모두 성공

실패 ❌:  둘 중하나의 작업이라도 실패하면 롤백하여 트랜잭션 실행 전의 상태

---

## Consistency (일관성)

- 데이터베이스의 상태가 일관되어야 한다.
- 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효
- 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다.

### 예제

데이터베이스의 규칙 : ‘모든 고객은 반드시 이름을 가지고 있어야 한다’

다음과 같은 트랜잭션은 일관성을 위반

- 이름 없는 새로운 고객을 추가
- 기존 고객의 이름을 삭제

---

## 🏝️  Isolation (독립성)

- 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다.
- 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜젝션은 고립되어 있어 연속으로 실행된 것과 동일한 결과를 나타낸다.

### 예제

A의 통장 잔고 200원

B에게 200원, C에게 200원을 동시에 계좌 이체하는 경우, 계좌 B에 먼저 송금한 뒤 계좌 C에 보내는 결과와 동일해야 한다.

❌ A의 잔고가 -200원이 되는 것이 아님

각 트랜잭션은 철저히 독립적이기 때문에, 다른 트랜잭션의 작업 내용을 알 수 없다.

---

## Durability (지속성)

- 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야하는 성질
- 런타임 오류나 시스템 오류가 발생하더라도, 해당 기록은 영구적이어야 한다.

### 예제

은행에서 계좌이체를 성공적으로 실행한 뒤에, 해당 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 기록으로 남아야 한다. 그 이전에 종료가 되면 이체 내역은 실패로 돌아가고 계좌들은 계좌이체 이전 상태들로 돌아가게 된다.

---

## 동시성 문제

하나의 프로그램이 여러 작업을 병렬로 처리할 때 발생

### 1. 경쟁 조건

여러 스레드나 프로세스가 공유 데이터나 리소스에 접근하고 수정할 때, 어떤 스레드가 먼저 접근하여 데이터를 변경하면 다른 스레드가 그 변경을 덮어쓰는 상황이 발생. 이로인해 데이터의 무결성이 깨질 수 있다.

### 2. 데드락

두 개 이상의 프로세스나 스레드가 서로가 가진 리소스를 기다리면서 상호 대기하는 상황. 각각의 프로세스나 스레드는 다른 리소스를 해제하지 않고 대기하므로 프로그램이 더 이상 진행되지 못하고 멈추게 된다.

### 3. 스레드 간 통신

여러 스레드가 작업을 나누어 수행할 때, 스레드 간에 정보를 안전하게 전달하고 동기화하는 문제가 발생할 수 있고, 이로 인해 잘못된 정보 전달이나 불일치가 발생할 수 있다.

---

참고 사이트 : 

https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/

https://mommoo.tistory.com/62

---

# @Transactional 어노테이션의 사용법

## @Transactional 이란?

@Transactional 어노테이션은 Spring에서 제공하는 기능으로 해당 메소드 내의 모든 데이터베이스 접근 작업이 하나의 트랜잭션으로 묶이게 된다. 이를 통해 데이터베이스 작업의 일관성을 보장하고, 트랜잭션 내에서 실행되는 모든 쿼리가 성공해야만 커밋되고, 하나라도 실패하면 롤백되는 것을 의미한다.

- [AOP가 적용되어 있다.](https://velog.io/@kyu0/Spring-Boot-AOPAspect-Oriented-Programming-%EC%A0%81%EC%9A%A9)
- 여러 개의 데이터베이스 작업을 하나의 트랜잭션으로 처리해야 할 때 유용
- 데이터베이스 작업 간의 일관성을 유지하고 데이터베이스에 대한 안전한 업데이트 또는 롤백을 보장

---

## @Transactional 사용법

### 1. 메소드에 직접 붙이기

특정 메소드 내의 모든 모든 데이터베이스 작업을 하나의 트랜잭션으로 묶고 싶을 때 해당 메소드에 붙임

```java
@Transactional
public void Method() {
	// database 작업
}
```

### 2. 클래스에 붙이기

클래스 레벨에 애노테이션을 붙여 클래스 내의 모든 메소드가 트랜잭션으로 처리된다.

주로 Service단에서 Repository를 통해 DB에 접근하는 로직을 구현하면, 이 활용방법을 주로 사용

```java
@Transactional
public class AnyService {
	public void method1() {
		// database 작업
	}
	
	public void method2() {
		// database 작업
	}
}
```

### 3. 스프링 구성 클래스 또는 XML 설정에서 붙이기

@Configuration 어노테이션이 붙은 스프링 구성 클래스나 XML 설정 파일에서 @EnableTransactionManagement 애노테이션을 사용하여 트랜잭션 관리를 활성화하고, 다음과 같이 특정 패키지 또는 클래스에 대한 트랜잭션 관리를 설정 할 수 있다.

```java
@Configuration
@EnableTransactionManagement
public class MyTransactionConfig {
    // 트랜잭션 설정 및 패키지 레벨의 @Transactional 설정 가능
}
```

### 4. 메소드 레벨에 커스텀 애노테이션으로 붙이기

커스텀 애노테이션을 정의하고, 이 애노테이션을 사용하여 메소드에 트랜잭션을 적용할 수 있다.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
public @interface CustomTransactional {
}

// 사용 예시
@CustomTransactional
public void customTransactionMethod() {
    // 데이터베이스 작업
}
```

가장 많이 사용되는 방식은 1번과 2번이나, 설정을 더 세밀하게 제어하기 위해 3번 방식을 사용한다.

## 왜 사용하는가???

- 앞서 말한 동시성 문제를 해결하기 위하여 사용

### 활용

여러 사용자가 동시에 데이터베이스에 접근할 때 발생할 수 있는 동시성 이슈를 효과적으로 관리할 수 있다.

```java
@Service
@Transactional
public class MyService {
    @Autowired
    private MyRepository myRepository;

    public void updateData() {
        // 여러 데이터베이스 작업 수행
        myRepository.updateRecord1();
        myRepository.updateRecord2();
        // ...
    }
}
```

→ 메소드 내에서 모든 데이터베이스 작업이 하나의 트랜잭션으로 처리되어, 다른 사용자와의 충돌을 방지하고 데이터 일관성을 유지할 수 있다.

---

# @Transactional 속성

## Propagation

트랜잭션의 전파 타입을 정하는 속성

- 이미 트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할지 결정하는 것이 전파 속성(Propagation)

| 전파 타입 | 설명 |
| --- | --- |
| REQUIRED | 기본값으로 설정되는 전파 타입. 기존에 활성화된 트랜잭션에 자식 트랜잭션이 합류하여 하나의 트랜잭션으로 취급하는 타입으로, 둘 중 하나의 트랜잭션에서 예외가 발생하면 모두 롤백 |
| REQUIRED_NEW | 기존에 활성화된 트랜잭션이 있더라도 합류하지 않고 별개의 트랜잭션으로 취급하여 수행되는 전파 타입. 
예외가 발생한 트랜잭션에서만 롤백이 수행 |
| SUPPORTS | 기존에 활성화된 트랜잭션이 있다면 합류를 하고, 활성화된 트랜잭션이 없다면 합류하지 않고 트랜잭션 없이 그대로 작업을 수행. 트랜잭션이 그닥 필요없는 SELECT 쿼리에 유용 |
| NOT_SUPORTED | 기존에 활성화된 트랜잭션 유무에 상관없이 트랜잭션 없이 작업을 수행한다. 활성화된 트랜잭션이 존재한다면 일시정지 후 작업을 완료하고 재시작을 하는 동작을 거치게 된다. |
| MANDATORY | 기존에 활성화된 트랜잭션이 존재할 경우 해당 트랜잭션에 합류하며, 존재하지 않을 경우 예외를 발생 |
| NEVER | 기존에 할성화된 트랜잭션이 존재할 경우 예외를 발생시키며, 할성화된 트랜잭션이 없을 경우 활성화된 트랜잭션에 합류하지 않고 작업을 수행 |
| NESTED | 기존에 할성화된 트랜잭션이 존재할 경우, save point를 표시하며 예외가 발생할 경우 해당 save point 지점으로 롤백된다. 할성화된 트랜잭션이 존재하지 않을 경우 REQUIRED와 같이 동작 |

### REQUIRED

![스크린샷 2024-11-12 22.01.18.png](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%2013c93df08ef28098b372ccc426f910b6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-12_22.01.18.png)

### REQUIRED_NEW

![스크린샷 2024-11-12 22.02.27.png](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%2013c93df08ef28098b372ccc426f910b6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-12_22.02.27.png)

---

## Isolation

트랜잭션에서 격리성을 보장하려면 트랜잭션을 요청한 순서대로 실행해야 하는데, 병렬 처리가 불가능하므로 성능이 나빠자는 문제를 해결하기 위해 격리수준을 4단계로 나누어 트랜잭션을 최대한 동시 처리 할 수 있도록 설계

- Dirty READ
    - 변경사항이 반영되지 않은 값을 다른 트랜잭션에서 읽도록 허용할 경우 발생하는 데이터 불일치
        
        ![스크린샷 2024-11-13 10.45.00.png](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%2013c93df08ef28098b372ccc426f910b6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-13_10.45.00.png)
        
- Non-Repeatable Read
    - 한 트랜잭션 내에서 값을 조회할 때, 동시성 문제로 인하여 같은 쿼리가 다른 결과를 반환하는 경우
    
    ![스크린샷 2024-11-13 10.45.14.png](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%2013c93df08ef28098b372ccc426f910b6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-13_10.45.14.png)
    
- Phantom Read
    - 외부에서 수행되는 입력/삭제 작업으로 인해 트랜잭션 내에서의 동일한 쿼리가 다른 값을 반환하는 경우
        
        ![스크린샷 2024-11-13 10.45.28.png](3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%92%E1%85%A1%E1%86%A8%E1%84%89%E1%85%B3%E1%86%B8%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%2013c93df08ef28098b372ccc426f910b6/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-11-13_10.45.28.png)
        
    

| 격리수준 | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| 커밋되지 않을 읽기
READ_UNCOMMITED | O | O | O |
| 커밋된 읽기
READ_COMMITED |  | O | O |
| 반복 가능한 읽기
REPEATABLE_READ |  |  | O |
| 직렬화 가능
SERIALIZABLE |  |  |  |

아래로 갈수록 높은 Level의 Isolation이며, 수준을 높일 경우 데이터의 일관성은 향상되나 동시성은 저하되어 성능 저하의 우려가 있으므로 고려하여 설정을 진행하여야 한다.

```java
@Transactional(isolation=Isolation.READ_COMMITED)
public void method() {
	// database 작업
}
```

---

## readOnly

@Transactional은 readOnly 속성을 통해 해당 트랜잭션을 읽기 전용으로 설정 가능하다.

- default
    - readOnly = false
- readOnly = true
    - 스프링이 해당 트랜잭션의 FlushMode=Never로 설정
    - flush가 일어나지 않으면 COST 절감, 스냅샷을 생성하지 않아 성능의 이점

→ 성는 최적화 목적 / 트랜잭션 작업 내 쓰기 작업을 의도적으로 방지

```java
@Transactional(readOnly=true)
public void method() {
	// database 작업
}
```

---

# 🔒 비관적 락 / 낙관적 락

JPA를 사용시 READ COMMITTED 이상의 격리 수준이 필요할 때, 비관적 락과 낙관적 락을 선택해야 한다.

## 비관적 락 (Pessimistic Lock)

- 트랜잭션이 충돌한다고 가정하고 락을 건다.
- DBMS의 락 기능을 사용
- 데이터 수정시 즉시 트랜잭션 충돌 여부를 확인 가능

### JPA에서 사용법

- @Lock 애노테이션 사용

```java
public interface UserRepository extends JpaRepository<User, Long> {

	@Lock(LockModeType.PESSIMISTIC_WRITE)
	@Query("select b from User b where b.id = :id")
    User findByIdForUpdate(Long id);   
}
```

- PESSIMISTIC_READ
    - 다른 트랜잭션에서 읽기만 가능
- PESSIMISTIC_WRITE
    - 다른 트랜잭션에서 읽기, 쓰기 불가능
- PESSIMISTIC_FORCE_INCREMENT
    - 다른 트랜잭션에서 읽기, 쓰기 불가능 + 추가적으로 버저닝 수행

### 단점

조회한 레코드 자체에 락을 걸기 때문에 성능이 저하될 수 있다.

성능상 이슈가 발견되다면 낙관적 락을 고려

## 낙관적 락 (Optimistic Lock)

- 트랜잭션이 충돌하지 않는다고 가정
- 자원에 락을 걸어 선점하지 말고 커밋할 때 동시성 문제가 발생하면 그때 처리하자는 방식
- JPA에서는 자체적으로 제공하는 버전 관리 기능을 사용
- 트랜잭션을 커밋하기 전까지는 충돌 여부를 확인할 수 없다.

### JPA에서 사용법

- @Version을 엔티티에 추가하여 사용

```java
Entity
// Lombok 생략
public class Board {

    @Id
    @GeneratedValue
    private Long id;

    @Version
    private Long version;
    
}
```

이제 Entity를 수정할 때마다 JPA가 자체적으로 Versioning을 지원하기 때문에 조회 시점과 수정 시점이 다르면 `ObjectOptimisticLockingFailureException` 예외가 발생한다.

- OPTIMISTIC
    - 트랜잭션 시작 시 버전 점검이 수행되고, 트랜잭션 종료 시에도 버전 점검이 수행
    - 버전이 다르면 트랜잭션이 롤백
- OPTIMISTIC_FORCE_INCREMENT
    - 낙관적 락을 사용하면서 추가로 버전을 강제로 증가시킨다.
    - 관계를 가진 다른 엔터티가 수정되면 버전이 변경된다. (ex. 댓글이 수정되면 게시글도 버전이 변경된다.)
- READ
    - OPTIMISTIC과 동일
- WRITE
    - OPTIMSTIC_FORCE_INCREMENT와 동일
- NONE
    - 엔터티에 @Version이 적용된 필드가 있으면 낙관적 락을 적용

## Isolation level과 @Lock

- Isolation level은 해당 트랜잭션이 다른 트랜잭션에서 변경한 데이터를 볼 수 있는 기준을 정의
- Lock은 다른 트랜잭션에서 해당 데이터에 접근하는 것을 막는 기능을 수행

- 낙관적 락은 일반적으로 비관적 락보다 성능이 좋다.

데이터 성향에 따라 비관적 락이 좋은 경우도 존재

- 재고가 1
- 100만 사용자가 동시적으로 주문

→ 비관적 락의 경우 1명의 사용자 말고는 대기를 하다 트랜잭션 충돌 여부를 파악할 수 있다. 

→ 낙관적 락의 경우 동시 요청을 보낸 사용자가 처리를 순차적으로 하다 Commit을 하는 시점에 재고가 없음을 파악하고 롤백